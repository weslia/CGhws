<!DOCTYPE html>
<html>
<head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}
</style>
</head>
<body>
<div id="info">hw4: Class, Texture Animation, module, and Picking 打地鼠的雛形
</div>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
var camera, scene, renderer;
var raycaster ,mouse = new THREE.Vector2(), plane, pickables = []; // use for click event to get mouse x,y position
var flameMesh,flameGroup;
var candles = [], candlesMaxNumber = 10, candlesMinNumber = 5 , putRange = 200;

class Candle{
  constructor(x,y,z,name){
    // for pack all
    this.candle = new THREE.Group();
    this.candle.position.set(x,y,z);
    // Cylinder
    this.body = new THREE.Mesh (new THREE.CylinderGeometry(5,5,20,6), new THREE.MeshPhongMaterial({color: "red"}));
    this.wick = new THREE.Mesh (new THREE.CylinderGeometry(1,1,4,6), new THREE.MeshPhongMaterial({color: "gray"}));
    this.wick.position.y = 21.5;
    this.wick.name = name;
    this.body.position.y = 10;
    this.body.name = name;
    this.candle.add (this.wick);
    this.candle.add (this.body);
    // light 
    this.light = new THREE.PointLight( 0xffdc35, 1, 100 );
    this.light.power = 30;
    this.light.position.y = 28;
    this.candle.add (this.light);
    // flame
    this.flameGroup = new THREE.Group();
    this.flameGroup.position.set(0,21,0);
    this.loader = new THREE.TextureLoader();
    this.texture = this.loader.load('https://i.imgur.com/M2tr5Tm.png?1');
    this.texture.wrapS = THREE.RepeatWrapping;
    this.texture.wrapT = THREE.RepeatWrapping;
    this.texture.repeat.set (1/3,1/3);
    this.texture.offset.set (0,2/3);
    let texMat = new THREE.MeshBasicMaterial({
      map: this.texture,
      alphaTest:0.5
    });//\OAO/\\
    this.flameMesh = new THREE.Mesh(new THREE.PlaneGeometry(30,30), texMat);
    this.flameMesh.position.set(0,7,0);
    this.flameMesh.name = name;
    this.flameGroup.add(this.flameMesh);
    this.candle.add (this.flameGroup);
    this.flameInterval = setInterval (this.textureAnimate.bind(this), 100);
    // func judge
    this.isBurn = true;
    this.willBurn = false;
    this.count = (this.count === undefined) ? 1 : this.count;
  }

  textureAnimate() {
    this.count = (this.count === undefined) ? 1 : this.count;
    if(this.isBurn === true){
      if (this.flameMesh !== undefined) {
        this.texture = this.flameMesh.material.map;
        //console.log (`${textureAnimate.count}: [${texture.offset.x},${texture.offset.y}]`);
        this.texture.offset.x += 1/3;
        if (this.count % 3 === 0) {
          this.texture.offset.y -= 1/3;
        }
        this.count++;
      }
    }
  }
}

init();
animate();

function init() {
  // init canvas to show world
  renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setClearColor (0x888888);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  // init world and camera
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(0,200,200);
  camera.lookAt(0,0,0);
  // use for click event to get mouse x,y position
  raycaster = new THREE.Raycaster();
  document.addEventListener('pointerdown', onDocumentMouseDown, false);
  plane = new THREE.Mesh(new THREE.PlaneGeometry(240, 240), new THREE.MeshPhongMaterial ({
    color: "gray",
    transparent: true,
    opacity: 0.5,
    visible: true
  }));
  scene.add(plane);
  //plane.material.visible = false
  plane.rotation.x = -Math.PI / 2;
  
  // control camera need
	let controls = new THREE.OrbitControls (camera, renderer.domElement);
  // canvas auto adjust window size
  window.addEventListener('resize', onWindowResize, false);
  ////////////////////////////////////////////////////////////
  //makeFlame2();
  var candlesNumber = Math.ceil(Math.random() * (candlesMinNumber)) + candlesMaxNumber-candlesMinNumber;
  for(var i=0; i<candlesNumber; i++){
    candles.push(new Candle(Math.floor(Math.random() * putRange-putRange/2),0,Math.floor(Math.random() * putRange-putRange/2), "cand" + i));
    scene.add(candles[i].candle);
    pickables.push(candles[i].candle);
  }

}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  render();
  
  // billboard
  for(var i=0; i<candles.length; i++){
    var flag = false;
    candles[i].flameGroup.lookAt (camera.position);
  }
}

function render() {
  renderer.render(scene, camera);
}

function onDocumentMouseDown(event) {
  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables,true);
  if (intersects.length > 0) {
    console.log(intersects[0].point.x + " " + intersects[0].point.y + " " + intersects[0].point.z );
    for(var i=0; i<candles.length; i++){
      console.log(intersects[0].object.name);
      if(intersects[0].object.name == candles[i].body.name){
        candles[i].isBurn = !candles[i].isBurn;
        if (candles[i].isBurn) {
          candles[i].flameMesh.material.visible = true;
          candles[i].light.visible = true;
          candles[i].flameInterval = setInterval (candles[i].textureAnimate.bind(candles[i]), 100);
        } else {
          candles[i].flameMesh.material.visible = false;
          candles[i].light.visible = false;
          console.log(candles[i].flameInterval);
          clearInterval (candles[i].flameInterval);
          candles[i].willBurn = true;
          setTimeout(lighter.bind(candles[i]), 3000);
          
        }
        console.log(candles[i].isBurn);
      }
    }
  }
}

function lighter(){
  if(this.isBurn == false){
    this.flameMesh.material.visible = true;
    this.light.visible = true;
    this.flameInterval = setInterval (this.textureAnimate.bind(this), 100);
    this.isBurn = true;
    this.willBurn = false;
  }
}
</script>
</body>

</html>
